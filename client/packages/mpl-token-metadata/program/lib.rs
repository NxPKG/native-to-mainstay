// This file is autogenerated with https://github.com/nxpkg/native-to-mainstay

use mainstay_lang::prelude::*;

declare_id!("11111111111111111111111111111111");

#[program]
pub mod mpl_token_metadata {
    use super::*;

    pub fn create_metadata_accounts(
        ctx: Context<CreateMetadataAccounts>,
        data: Data,
        is_mutable: bool,
    ) -> Result<()> {
        Ok(())
    }

    pub fn update_metadata_accounts(
        ctx: Context<UpdateMetadataAccounts>,
        data: Option<Data>,
        update_authority: Option<Pubkey>,
        primary_sale_happened: Option<bool>,
    ) -> Result<()> {
        Ok(())
    }

    pub fn deprecated_create_master_edition(
        ctx: Context<DeprecatedCreateMasterEdition>,
        max_supply: Option<u64>,
    ) -> Result<()> {
        Ok(())
    }

    pub fn deprecated_mint_new_edition_from_master_edition_via_printing_token(
        ctx: Context<DeprecatedMintNewEditionFromMasterEditionViaPrintingToken>,
    ) -> Result<()> {
        Ok(())
    }

    pub fn update_primary_sale_happened_via_token(
        ctx: Context<UpdatePrimarySaleHappenedViaToken>,
    ) -> Result<()> {
        Ok(())
    }

    pub fn deprecated_set_reservation_list(
        ctx: Context<DeprecatedSetReservationList>,
        arg: SetReservationListArgs,
    ) -> Result<()> {
        Ok(())
    }

    pub fn deprecated_create_reservation_list(
        ctx: Context<DeprecatedCreateReservationList>,
    ) -> Result<()> {
        Ok(())
    }

    pub fn sign_metadata(ctx: Context<SignMetadata>) -> Result<()> {
        Ok(())
    }

    pub fn deprecated_mint_printing_tokens_via_token(
        ctx: Context<DeprecatedMintPrintingTokensViaToken>,
        arg: MintPrintingTokensViaTokenArgs,
    ) -> Result<()> {
        Ok(())
    }

    pub fn deprecated_mint_printing_tokens(
        ctx: Context<DeprecatedMintPrintingTokens>,
        arg: MintPrintingTokensViaTokenArgs,
    ) -> Result<()> {
        Ok(())
    }

    pub fn create_master_edition(
        ctx: Context<CreateMasterEdition>,
        max_supply: Option<u64>,
    ) -> Result<()> {
        Ok(())
    }

    pub fn mint_new_edition_from_master_edition_via_token(
        ctx: Context<MintNewEditionFromMasterEditionViaToken>,
        edition: u64,
    ) -> Result<()> {
        Ok(())
    }

    pub fn convert_master_edition_v1_to_v2(ctx: Context<ConvertMasterEditionV1ToV2>) -> Result<()> {
        Ok(())
    }

    pub fn mint_edition_from_master_edition_via_vault_proxy(
        ctx: Context<MintEditionFromMasterEditionViaVaultProxy>,
        edition: u64,
    ) -> Result<()> {
        Ok(())
    }

    pub fn puff_metadata_account(ctx: Context<PuffMetadataAccount>) -> Result<()> {
        Ok(())
    }

    pub fn update_metadata_account_v2(
        ctx: Context<UpdateMetadataAccountV2>,
        data: Option<DataV2>,
        update_authority: Option<Pubkey>,
        primary_sale_happened: Option<bool>,
        is_mutable: Option<bool>,
    ) -> Result<()> {
        Ok(())
    }

    pub fn create_metadata_account_v2(
        ctx: Context<CreateMetadataAccountV2>,
        data: DataV2,
        is_mutable: bool,
    ) -> Result<()> {
        Ok(())
    }

    pub fn create_master_edition_v3(
        ctx: Context<CreateMasterEditionV3>,
        max_supply: Option<u64>,
    ) -> Result<()> {
        Ok(())
    }

    pub fn verify_collection(ctx: Context<VerifyCollection>) -> Result<()> {
        Ok(())
    }

    pub fn utilize(ctx: Context<Utilize>, number_of_uses: u64) -> Result<()> {
        Ok(())
    }

    pub fn approve_use_authority(
        ctx: Context<ApproveUseAuthority>,
        number_of_uses: u64,
    ) -> Result<()> {
        Ok(())
    }

    pub fn revoke_use_authority(ctx: Context<RevokeUseAuthority>) -> Result<()> {
        Ok(())
    }

    pub fn unverify_collection(ctx: Context<UnverifyCollection>) -> Result<()> {
        Ok(())
    }

    pub fn approve_collection_authority(ctx: Context<ApproveCollectionAuthority>) -> Result<()> {
        Ok(())
    }

    pub fn revoke_collection_authority(ctx: Context<RevokeCollectionAuthority>) -> Result<()> {
        Ok(())
    }

    pub fn set_and_verify_collection(ctx: Context<SetAndVerifyCollection>) -> Result<()> {
        Ok(())
    }

    pub fn freeze_delegated_account(ctx: Context<FreezeDelegatedAccount>) -> Result<()> {
        Ok(())
    }

    pub fn thaw_delegated_account(ctx: Context<ThawDelegatedAccount>) -> Result<()> {
        Ok(())
    }

    pub fn remove_creator_verification(ctx: Context<RemoveCreatorVerification>) -> Result<()> {
        Ok(())
    }

    pub fn burn_nft(ctx: Context<BurnNft>) -> Result<()> {
        Ok(())
    }

    pub fn verify_sized_collection_item(ctx: Context<VerifySizedCollectionItem>) -> Result<()> {
        Ok(())
    }

    pub fn unverify_sized_collection_item(ctx: Context<UnverifySizedCollectionItem>) -> Result<()> {
        Ok(())
    }

    pub fn set_and_verify_sized_collection_item(
        ctx: Context<SetAndVerifySizedCollectionItem>,
    ) -> Result<()> {
        Ok(())
    }

    pub fn create_metadata_account_v3(
        ctx: Context<CreateMetadataAccountV3>,
        data: DataV2,
        is_mutable: bool,
        collection_details: Option<CollectionDetails>,
    ) -> Result<()> {
        Ok(())
    }

    pub fn set_collection_size(ctx: Context<SetCollectionSize>, size: u64) -> Result<()> {
        Ok(())
    }

    pub fn set_token_standard(ctx: Context<SetTokenStandard>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateMetadataAccounts<'info> {
    #[account(mut)]
    metadata_account: AccountInfo<'info>,
    mint: AccountInfo<'info>,
    mint_authority: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    update_authority: Signer<'info>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct UpdateMetadataAccounts<'info> {
    #[account(mut)]
    metadata_account: AccountInfo<'info>,
    update_authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct DeprecatedCreateMasterEdition<'info> {
    #[account(mut)]
    edition: AccountInfo<'info>,
    #[account(mut)]
    mint: AccountInfo<'info>,
    #[account(mut)]
    printing_mint: AccountInfo<'info>,
    #[account(mut)]
    one_time_printing_authorization_mint: AccountInfo<'info>,
    update_authority: Signer<'info>,
    printing_mint_authority: Signer<'info>,
    mint_authority: Signer<'info>,
    metadata: AccountInfo<'info>,
    payer: AccountInfo<'info>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
    // optional_auth: Signer<'info>,
}

#[derive(Accounts)]
pub struct DeprecatedMintNewEditionFromMasterEditionViaPrintingToken<'info> {
    #[account(mut)]
    metadata: AccountInfo<'info>,
    #[account(mut)]
    edition: AccountInfo<'info>,
    #[account(mut)]
    master_edition: AccountInfo<'info>,
    #[account(mut)]
    mint: AccountInfo<'info>,
    mint_authority: Signer<'info>,
    #[account(mut)]
    printing_mint: AccountInfo<'info>,
    #[account(mut)]
    master_token_account: AccountInfo<'info>,
    burn_authority: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    master_update_authority: Signer<'info>,
    master_metadata: AccountInfo<'info>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
    // optional_list: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct UpdatePrimarySaleHappenedViaToken<'info> {
    #[account(mut)]
    metadata: AccountInfo<'info>,
    owner: Signer<'info>,
    token: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct DeprecatedSetReservationList<'info> {
    #[account(mut)]
    master_edition: AccountInfo<'info>,
    #[account(mut)]
    reservation_list: AccountInfo<'info>,
    resource: Signer<'info>,
}

#[derive(Accounts)]
pub struct DeprecatedCreateReservationList<'info> {
    #[account(mut)]
    reservation_list: AccountInfo<'info>,
    payer: Signer<'info>,
    update_authority: Signer<'info>,
    master_edition: AccountInfo<'info>,
    resource: AccountInfo<'info>,
    metadata: AccountInfo<'info>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct SignMetadata<'info> {
    #[account(mut)]
    metadata: AccountInfo<'info>,
    creator: Signer<'info>,
}

#[derive(Accounts)]
pub struct DeprecatedMintPrintingTokensViaToken<'info> {
    #[account(mut)]
    destination: AccountInfo<'info>,
    #[account(mut)]
    token: AccountInfo<'info>,
    #[account(mut)]
    one_time_printing_authorization_mint: AccountInfo<'info>,
    #[account(mut)]
    printing_mint: AccountInfo<'info>,
    burn_authority: Signer<'info>,
    metadata: AccountInfo<'info>,
    master_edition: AccountInfo<'info>,
    token_program: Program<'info, Token>,
    rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct DeprecatedMintPrintingTokens<'info> {
    #[account(mut)]
    destination: AccountInfo<'info>,
    #[account(mut)]
    printing_mint: AccountInfo<'info>,
    update_authority: Signer<'info>,
    metadata: AccountInfo<'info>,
    master_edition: AccountInfo<'info>,
    token_program: Program<'info, Token>,
    rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct CreateMasterEdition<'info> {
    #[account(mut)]
    edition: AccountInfo<'info>,
    #[account(mut)]
    mint: AccountInfo<'info>,
    update_authority: Signer<'info>,
    mint_authority: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    metadata: AccountInfo<'info>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct MintNewEditionFromMasterEditionViaToken<'info> {
    #[account(mut)]
    new_metadata: AccountInfo<'info>,
    #[account(mut)]
    new_edition: AccountInfo<'info>,
    #[account(mut)]
    master_edition: AccountInfo<'info>,
    #[account(mut)]
    new_mint: AccountInfo<'info>,
    #[account(mut)]
    edition_mark_pda: AccountInfo<'info>,
    new_mint_authority: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    token_account_owner: Signer<'info>,
    token_account: AccountInfo<'info>,
    new_metadata_update_authority: AccountInfo<'info>,
    metadata: AccountInfo<'info>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct ConvertMasterEditionV1ToV2<'info> {
    #[account(mut)]
    master_edition: AccountInfo<'info>,
    #[account(mut)]
    one_time_auth: AccountInfo<'info>,
    #[account(mut)]
    printing_mint: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct MintEditionFromMasterEditionViaVaultProxy<'info> {
    #[account(mut)]
    new_metadata: AccountInfo<'info>,
    #[account(mut)]
    new_edition: AccountInfo<'info>,
    #[account(mut)]
    master_edition: AccountInfo<'info>,
    #[account(mut)]
    new_mint: AccountInfo<'info>,
    #[account(mut)]
    edition_mark_pda: AccountInfo<'info>,
    new_mint_authority: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    vault_authority: Signer<'info>,
    safety_deposit_store: AccountInfo<'info>,
    safety_deposit_box: AccountInfo<'info>,
    vault: AccountInfo<'info>,
    new_metadata_update_authority: AccountInfo<'info>,
    metadata: AccountInfo<'info>,
    token_program: Program<'info, Token>,
    token_vault_program_info: AccountInfo<'info>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct PuffMetadataAccount<'info> {
    #[account(mut)]
    metadata_account: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct UpdateMetadataAccountV2<'info> {
    #[account(mut)]
    metadata_account: AccountInfo<'info>,
    update_authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct CreateMetadataAccountV2<'info> {
    #[account(mut)]
    metadata_account: AccountInfo<'info>,
    mint: AccountInfo<'info>,
    mint_authority: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    update_authority: Signer<'info>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct CreateMasterEditionV3<'info> {
    #[account(mut)]
    edition: AccountInfo<'info>,
    #[account(mut)]
    mint: AccountInfo<'info>,
    update_authority: Signer<'info>,
    mint_authority: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    #[account(mut)]
    metadata: AccountInfo<'info>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct VerifyCollection<'info> {
    #[account(mut)]
    metadata: AccountInfo<'info>,
    #[account(mut)]
    collection_authority: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    collection_mint: AccountInfo<'info>,
    collection: AccountInfo<'info>,
    collection_master_edition_account: AccountInfo<'info>,
    // optional_collection_authority_record: Signer<'info>,
}

#[derive(Accounts)]
pub struct Utilize<'info> {
    #[account(mut)]
    metadata: AccountInfo<'info>,
    #[account(mut)]
    token_account: AccountInfo<'info>,
    #[account(mut)]
    mint: AccountInfo<'info>,
    #[account(mut)]
    use_authority: Signer<'info>,
    owner: AccountInfo<'info>,
    token_program: Program<'info, Token>,
    spl_associated_token_account: AccountInfo<'info>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
    // #[account(mut)]
    // optional_use_authority_record_pda: AccountInfo<'info>,
    // optional_burner: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct ApproveUseAuthority<'info> {
    #[account(mut)]
    use_authority_record: AccountInfo<'info>,
    #[account(mut)]
    owner: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    user: AccountInfo<'info>,
    #[account(mut)]
    owner_token_account: AccountInfo<'info>,
    metadata: AccountInfo<'info>,
    mint: AccountInfo<'info>,
    burner: AccountInfo<'info>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct RevokeUseAuthority<'info> {
    #[account(mut)]
    use_authority_record: AccountInfo<'info>,
    #[account(mut)]
    owner: Signer<'info>,
    user: AccountInfo<'info>,
    #[account(mut)]
    owner_token_account: AccountInfo<'info>,
    mint: AccountInfo<'info>,
    metadata: AccountInfo<'info>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct UnverifyCollection<'info> {
    #[account(mut)]
    metadata: AccountInfo<'info>,
    #[account(mut)]
    collection_authority: Signer<'info>,
    collection_mint: AccountInfo<'info>,
    collection: AccountInfo<'info>,
    collection_master_edition_account: AccountInfo<'info>,
    // optional_collection_authority_record: Signer<'info>,
}

#[derive(Accounts)]
pub struct ApproveCollectionAuthority<'info> {
    #[account(mut)]
    collection_authority_record: AccountInfo<'info>,
    new_collection_authority: AccountInfo<'info>,
    #[account(mut)]
    update_authority: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    metadata: AccountInfo<'info>,
    mint: AccountInfo<'info>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct RevokeCollectionAuthority<'info> {
    #[account(mut)]
    collection_authority_record: AccountInfo<'info>,
    delegate_authority: AccountInfo<'info>,
    #[account(mut)]
    revoke_authority: Signer<'info>,
    metadata: AccountInfo<'info>,
    mint: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct SetAndVerifyCollection<'info> {
    #[account(mut)]
    metadata: AccountInfo<'info>,
    #[account(mut)]
    collection_authority: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    update_authority: AccountInfo<'info>,
    collection_mint: AccountInfo<'info>,
    collection: AccountInfo<'info>,
    collection_master_edition_account: AccountInfo<'info>,
    // optional_collection_authority_record: Signer<'info>,
}

#[derive(Accounts)]
pub struct FreezeDelegatedAccount<'info> {
    #[account(mut)]
    delegate: Signer<'info>,
    #[account(mut)]
    token_account: AccountInfo<'info>,
    edition: AccountInfo<'info>,
    mint: AccountInfo<'info>,
    token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct ThawDelegatedAccount<'info> {
    #[account(mut)]
    delegate: Signer<'info>,
    #[account(mut)]
    token_account: AccountInfo<'info>,
    edition: AccountInfo<'info>,
    mint: AccountInfo<'info>,
    token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct RemoveCreatorVerification<'info> {
    #[account(mut)]
    metadata: AccountInfo<'info>,
    creator: Signer<'info>,
}

#[derive(Accounts)]
pub struct BurnNft<'info> {
    #[account(mut)]
    metadata: AccountInfo<'info>,
    #[account(mut)]
    owner: Signer<'info>,
    #[account(mut)]
    mint: AccountInfo<'info>,
    #[account(mut)]
    token: AccountInfo<'info>,
    #[account(mut)]
    edition: AccountInfo<'info>,
    token_program: Program<'info, Token>,
    // #[account(mut)]
    // optional_collection_metadata: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct VerifySizedCollectionItem<'info> {
    #[account(mut)]
    metadata: AccountInfo<'info>,
    collection_authority: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    collection_mint: AccountInfo<'info>,
    #[account(mut)]
    collection: AccountInfo<'info>,
    collection_master_edition_account: AccountInfo<'info>,
    // optional_record: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct UnverifySizedCollectionItem<'info> {
    #[account(mut)]
    metadata: AccountInfo<'info>,
    collection_authority: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    collection_mint: AccountInfo<'info>,
    #[account(mut)]
    collection: AccountInfo<'info>,
    collection_master_edition_account: AccountInfo<'info>,
    // optional_collection_authority_record: Signer<'info>,
}

#[derive(Accounts)]
pub struct SetAndVerifySizedCollectionItem<'info> {
    #[account(mut)]
    metadata: AccountInfo<'info>,
    #[account(mut)]
    collection_authority: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    update_authority: AccountInfo<'info>,
    collection_mint: AccountInfo<'info>,
    #[account(mut)]
    collection: AccountInfo<'info>,
    collection_master_edition_account: AccountInfo<'info>,
    // optional_collection_authority_record: Signer<'info>,
}

#[derive(Accounts)]
pub struct CreateMetadataAccountV3<'info> {
    #[account(mut)]
    metadata_account: AccountInfo<'info>,
    mint: AccountInfo<'info>,
    mint_authority: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    update_authority: Signer<'info>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct SetCollectionSize<'info> {
    #[account(mut)]
    metadata_account: AccountInfo<'info>,
    update_authority: Signer<'info>,
    mint: AccountInfo<'info>,
    // optional_record: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct SetTokenStandard<'info> {
    #[account(mut)]
    metadata_account: AccountInfo<'info>,
    #[account(mut)]
    update_authority: Signer<'info>,
    mint_account: AccountInfo<'info>,
    // optional_edition_account: AccountInfo<'info>,
}

#[account]
pub struct CollectionAuthorityRecord {
    pub key: Key, //1
    pub bump: u8, //1
}

#[account]
pub struct Edition {
    pub key: Key,

    /// Points at MasterEdition struct
    pub parent: Pubkey,

    /// Starting at 0 for master record, this is incremented for each edition minted.
    pub edition: u64,
}

#[account]
pub struct EditionMarker {
    pub key: Key,
    pub ledger: [u8; 31],
}

#[account]
pub struct MasterEditionV2 {
    pub key: Key,

    pub supply: u64,

    pub max_supply: Option<u64>,
}

#[account]
pub struct MasterEditionV1 {
    pub key: Key,

    pub supply: u64,

    pub max_supply: Option<u64>,

    /// Can be used to mint tokens that give one-time permission to mint a single limited edition.
    pub printing_mint: Pubkey,

    /// If you don't know how many printing tokens you are going to need, but you do know
    /// you are going to need some amount in the future, you can use a token from this mint.
    /// Coming back to token metadata with one of these tokens allows you to mint (one time)
    /// any number of printing tokens you want. This is used for instance by Auction Manager
    /// with participation NFTs, where we dont know how many people will bid and need participation
    /// printing tokens to redeem, so we give it ONE of these tokens to use after the auction is over,
    /// because when the auction begins we just dont know how many printing tokens we will need,
    /// but at the end we will. At the end it then burns this token with token-metadata to
    /// get the printing tokens it needs to give to bidders. Each bidder then redeems a printing token
    /// to get their limited editions.
    pub one_time_printing_authorization_mint: Pubkey,
}

#[account]
pub struct Metadata {
    pub key: Key,
    pub update_authority: Pubkey,
    pub mint: Pubkey,
    pub data: Data,
    // Immutable, once flipped, all sales of this metadata are considered secondary.
    pub primary_sale_happened: bool,
    // Whether or not the data struct is mutable, default is not
    pub is_mutable: bool,
    /// nonce for easy calculation of editions, if present
    pub edition_nonce: Option<u8>,
    /// Since we cannot easily change Metadata, we add the new DataV2 fields here at the end.
    pub token_standard: Option<TokenStandard>,
    /// Collection
    pub collection: Option<Collection>,
    /// Uses
    pub uses: Option<Uses>,
    /// Item Details
    pub collection_details: Option<CollectionDetails>,
}

#[account]
pub struct ReservationListV1 {
    pub key: Key,
    /// Present for reverse lookups
    pub master_edition: Pubkey,

    /// What supply counter was on master_edition when this reservation was created.
    pub supply_snapshot: Option<u64>,
    pub reservations: Vec<ReservationV1>,
}

#[account]
pub struct ReservationListV2 {
    pub key: Key,
    /// Present for reverse lookups
    pub master_edition: Pubkey,

    /// What supply counter was on master_edition when this reservation was created.
    pub supply_snapshot: Option<u64>,
    pub reservations: Vec<Reservation>,
    /// How many reservations there are going to be, given on first set_reservation call
    pub total_reservation_spots: u64,
    /// Cached count of reservation spots in the reservation vec to save on CPU.
    pub current_reservation_spots: u64,
}

#[account]
pub struct UseAuthorityRecord {
    pub key: Key,          //1
    pub allowed_uses: u64, //8
    pub bump: u8,
}

#[derive(MainstaySerialize, MainstayDeserialize)]
pub struct Creator {
    #[cfg_attr(feature = "serde-feature", serde(with = "As::<DisplayFromStr>"))]
    pub address: Pubkey,
    pub verified: bool,
    // In percentages, NOT basis points ;) Watch out!
    pub share: u8,
}

#[derive(MainstaySerialize, MainstayDeserialize)]
pub struct Data {
    /// The name of the asset
    pub name: String,
    /// The symbol for the asset
    pub symbol: String,
    /// URI pointing to JSON representing the asset
    pub uri: String,
    /// Royalty basis points that goes to creators in secondary sales (0-10000)
    pub seller_fee_basis_points: u16,
    /// Array of creators, optional
    pub creators: Option<Vec<Creator>>,
}

#[derive(MainstaySerialize, MainstayDeserialize)]
pub struct Collection {
    pub verified: bool,
    pub key: Pubkey,
}

#[derive(MainstaySerialize, MainstayDeserialize)]
pub struct Uses {
    // 17 bytes + Option byte
    pub use_method: UseMethod, //1
    pub remaining: u64,        //8
    pub total: u64,            //8
}

#[derive(MainstaySerialize, MainstayDeserialize)]
pub struct DataV2 {
    /// The name of the asset
    pub name: String,
    /// The symbol for the asset
    pub symbol: String,
    /// URI pointing to JSON representing the asset
    pub uri: String,
    /// Royalty basis points that goes to creators in secondary sales (0-10000)
    pub seller_fee_basis_points: u16,
    /// Array of creators, optional
    pub creators: Option<Vec<Creator>>,
    /// Collection
    pub collection: Option<Collection>,
    /// Uses
    pub uses: Option<Uses>,
}

#[derive(MainstaySerialize, MainstayDeserialize)]
pub enum Key {
    Uninitialized,
    EditionV1,
    MasterEditionV1,
    ReservationListV1,
    MetadataV1,
    ReservationListV2,
    MasterEditionV2,
    EditionMarker,
    UseAuthorityRecord,
    CollectionAuthorityRecord,
}

#[derive(MainstaySerialize, MainstayDeserialize)]
pub enum TokenStandard {
    NonFungible,        // This is a master edition
    FungibleAsset,      // A token with metadata that can also have attrributes
    Fungible,           // A token with simple metadata
    NonFungibleEdition, // This is a limited edition
}

#[derive(MainstaySerialize, MainstayDeserialize)]
pub enum CollectionDetails {
    V1 { size: u64 },
}

#[derive(MainstaySerialize, MainstayDeserialize)]
pub struct Reservation {
    pub address: Pubkey,
    pub spots_remaining: u64,
    pub total_spots: u64,
}

#[derive(MainstaySerialize, MainstayDeserialize)]
pub struct ReservationV1 {
    pub address: Pubkey,
    pub spots_remaining: u8,
    pub total_spots: u8,
}

#[derive(MainstaySerialize, MainstayDeserialize)]
pub enum UseMethod {
    Burn,
    Multiple,
    Single,
}

#[derive(MainstaySerialize, MainstayDeserialize)]
pub struct SetReservationListArgs {
    /// If set, means that no more than this number of editions can ever be minted. This is immutable.
    pub reservations: Vec<Reservation>,
    /// should only be present on the very first call to set reservation list.
    pub total_reservation_spots: Option<u64>,
    /// Where in the reservation list you want to insert this slice of reservations
    pub offset: u64,
    /// What the total spot offset is in the reservation list from the beginning to your slice of reservations.
    /// So if is going to be 4 total editions eventually reserved between your slice and the beginning of the array,
    /// split between 2 reservation entries, the offset variable above would be "2" since you start at entry 2 in 0 indexed array
    /// (first 2 taking 0 and 1) and because they each have 2 spots taken, this variable would be 4.
    pub total_spot_offset: u64,
}

#[derive(MainstaySerialize, MainstayDeserialize)]
pub struct MintPrintingTokensViaTokenArgs {
    pub supply: u64,
}

#[error_code]
pub enum MetadataError {
    /// 0 Failed to unpack instruction data
    #[msg("Failed to unpack instruction data")]
    InstructionUnpackError,

    /// Failed to pack instruction data
    #[msg("Failed to pack instruction data")]
    InstructionPackError,

    /// Lamport balance below rent-exempt threshold.
    #[msg("Lamport balance below rent-exempt threshold")]
    NotRentExempt,

    /// Already initialized
    #[msg("Already initialized")]
    AlreadyInitialized,

    /// Uninitialized
    #[msg("Uninitialized")]
    Uninitialized,

    ///  Metadata's key must match seed of ['metadata', program id, mint] provided
    #[msg(" Metadata's key must match seed of ['metadata', program id, mint] provided")]
    InvalidMetadataKey,

    ///  Edition's key must match seed of ['metadata', program id, name, 'edition'] provided
    #[msg("Edition's key must match seed of ['metadata', program id, name, 'edition'] provided")]
    InvalidEditionKey,

    /// Update Authority given does not match
    #[msg("Update Authority given does not match")]
    UpdateAuthorityIncorrect,

    /// Update Authority needs to be signer to update metadata
    #[msg("Update Authority needs to be signer to update metadata")]
    UpdateAuthorityIsNotSigner,

    /// You must be the mint authority and signer on this transaction
    #[msg("You must be the mint authority and signer on this transaction")]
    NotMintAuthority,

    /// 10 - Mint authority provided does not match the authority on the mint
    #[msg("Mint authority provided does not match the authority on the mint")]
    InvalidMintAuthority,

    /// Name too long
    #[msg("Name too long")]
    NameTooLong,

    /// Symbol too long
    #[msg("Symbol too long")]
    SymbolTooLong,

    /// URI too long
    #[msg("URI too long")]
    UriTooLong,

    /// Update authority must be equivalent to the metadata's authority and also signer of this transaction
    #[msg("Update authority must be equivalent to the metadata's authority and also signer of this transaction")]
    UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner,

    /// Mint given does not match mint on Metadata
    #[msg("Mint given does not match mint on Metadata")]
    MintMismatch,

    /// Editions must have exactly one token
    #[msg("Editions must have exactly one token")]
    EditionsMustHaveExactlyOneToken,

    /// Maximum editions printed already
    #[msg("Maximum editions printed already")]
    MaxEditionsMintedAlready,

    /// Token mint to failed
    #[msg("Token mint to failed")]
    TokenMintToFailed,

    /// The master edition record passed must match the master record on the edition given
    #[msg("The master edition record passed must match the master record on the edition given")]
    MasterRecordMismatch,

    /// 20 - The destination account does not have the right mint
    #[msg("The destination account does not have the right mint")]
    DestinationMintMismatch,

    /// An edition can only mint one of its kind!
    #[msg("An edition can only mint one of its kind!")]
    EditionAlreadyMinted,

    /// Printing mint decimals should be zero
    #[msg("Printing mint decimals should be zero")]
    PrintingMintDecimalsShouldBeZero,

    /// OneTimePrintingAuthorizationMint mint decimals should be zero
    #[msg("OneTimePrintingAuthorization mint decimals should be zero")]
    OneTimePrintingAuthorizationMintDecimalsShouldBeZero,

    /// Edition mint decimals should be zero
    #[msg("EditionMintDecimalsShouldBeZero")]
    EditionMintDecimalsShouldBeZero,

    /// Token burn failed
    #[msg("Token burn failed")]
    TokenBurnFailed,

    /// The One Time authorization mint does not match that on the token account!
    #[msg("The One Time authorization mint does not match that on the token account!")]
    TokenAccountOneTimeAuthMintMismatch,

    /// Derived key invalid
    #[msg("Derived key invalid")]
    DerivedKeyInvalid,

    /// The Printing mint does not match that on the master edition!
    #[msg("The Printing mint does not match that on the master edition!")]
    PrintingMintMismatch,

    /// The  One Time Printing Auth mint does not match that on the master edition!
    #[msg("The One Time Printing Auth mint does not match that on the master edition!")]
    OneTimePrintingAuthMintMismatch,

    /// 30 - The mint of the token account does not match the Printing mint!
    #[msg("The mint of the token account does not match the Printing mint!")]
    TokenAccountMintMismatch,

    /// The mint of the token account does not match the master metadata mint!
    #[msg("The mint of the token account does not match the master metadata mint!")]
    TokenAccountMintMismatchV2,

    /// Not enough tokens to mint a limited edition
    #[msg("Not enough tokens to mint a limited edition")]
    NotEnoughTokens,

    /// The mint on your authorization token holding account does not match your Printing mint!
    #[msg(
        "The mint on your authorization token holding account does not match your Printing mint!"
    )]
    PrintingMintAuthorizationAccountMismatch,

    /// The authorization token account has a different owner than the update authority for the master edition!
    #[msg("The authorization token account has a different owner than the update authority for the master edition!")]
    AuthorizationTokenAccountOwnerMismatch,

    /// This feature is currently disabled.
    #[msg("This feature is currently disabled.")]
    Disabled,

    /// Creators list too long
    #[msg("Creators list too long")]
    CreatorsTooLong,

    /// Creators must be at least one if set
    #[msg("Creators must be at least one if set")]
    CreatorsMustBeAtleastOne,

    /// If using a creators array, you must be one of the creators listed
    #[msg("If using a creators array, you must be one of the creators listed")]
    MustBeOneOfCreators,

    /// This metadata does not have creators
    #[msg("This metadata does not have creators")]
    NoCreatorsPresentOnMetadata,

    /// 40 - This creator address was not found
    #[msg("This creator address was not found")]
    CreatorNotFound,

    /// Basis points cannot be more than 10000
    #[msg("Basis points cannot be more than 10000")]
    InvalidBasisPoints,

    /// Primary sale can only be flipped to true and is immutable
    #[msg("Primary sale can only be flipped to true and is immutable")]
    PrimarySaleCanOnlyBeFlippedToTrue,

    /// Owner does not match that on the account given
    #[msg("Owner does not match that on the account given")]
    OwnerMismatch,

    /// This account has no tokens to be used for authorization
    #[msg("This account has no tokens to be used for authorization")]
    NoBalanceInAccountForAuthorization,

    /// Share total must equal 100 for creator array
    #[msg("Share total must equal 100 for creator array")]
    ShareTotalMustBe100,

    /// This reservation list already exists!
    #[msg("This reservation list already exists!")]
    ReservationExists,

    /// This reservation list does not exist!
    #[msg("This reservation list does not exist!")]
    ReservationDoesNotExist,

    /// This reservation list exists but was never set with reservations
    #[msg("This reservation list exists but was never set with reservations")]
    ReservationNotSet,

    /// This reservation list has already been set!
    #[msg("This reservation list has already been set!")]
    ReservationAlreadyMade,

    /// 50 - Provided more addresses than max allowed in single reservation
    #[msg("Provided more addresses than max allowed in single reservation")]
    BeyondMaxAddressSize,

    /// NumericalOverflowError
    #[msg("NumericalOverflowError")]
    NumericalOverflowError,

    /// This reservation would go beyond the maximum supply of the master edition!
    #[msg("This reservation would go beyond the maximum supply of the master edition!")]
    ReservationBreachesMaximumSupply,

    /// Address not in reservation!
    #[msg("Address not in reservation!")]
    AddressNotInReservation,

    /// You cannot unilaterally verify another creator, they must sign
    #[msg("You cannot unilaterally verify another creator, they must sign")]
    CannotVerifyAnotherCreator,

    /// You cannot unilaterally unverify another creator
    #[msg("You cannot unilaterally unverify another creator")]
    CannotUnverifyAnotherCreator,

    /// In initial reservation setting, spots remaining should equal total spots
    #[msg("In initial reservation setting, spots remaining should equal total spots")]
    SpotMismatch,

    /// Incorrect account owner
    #[msg("Incorrect account owner")]
    IncorrectOwner,

    /// printing these tokens would breach the maximum supply limit of the master edition
    #[msg("printing these tokens would breach the maximum supply limit of the master edition")]
    PrintingWouldBreachMaximumSupply,

    /// Data is immutable
    #[msg("Data is immutable")]
    DataIsImmutable,

    /// 60 - No duplicate creator addresses
    #[msg("No duplicate creator addresses")]
    DuplicateCreatorAddress,

    /// Reservation spots remaining should match total spots when first being created
    #[msg("Reservation spots remaining should match total spots when first being created")]
    ReservationSpotsRemainingShouldMatchTotalSpotsAtStart,

    /// Invalid token program
    #[msg("Invalid token program")]
    InvalidTokenProgram,

    /// Data type mismatch
    #[msg("Data type mismatch")]
    DataTypeMismatch,

    /// Beyond alotted address size in reservation!
    #[msg("Beyond alotted address size in reservation!")]
    BeyondAlottedAddressSize,

    /// The reservation has only been partially alotted
    #[msg("The reservation has only been partially alotted")]
    ReservationNotComplete,

    /// You cannot splice over an existing reservation!
    #[msg("You cannot splice over an existing reservation!")]
    TriedToReplaceAnExistingReservation,

    /// Invalid operation
    #[msg("Invalid operation")]
    InvalidOperation,

    /// Invalid owner
    #[msg("Invalid Owner")]
    InvalidOwner,

    /// Printing mint supply must be zero for conversion
    #[msg("Printing mint supply must be zero for conversion")]
    PrintingMintSupplyMustBeZeroForConversion,

    /// 70 - One Time Auth mint supply must be zero for conversion
    #[msg("One Time Auth mint supply must be zero for conversion")]
    OneTimeAuthMintSupplyMustBeZeroForConversion,

    /// You tried to insert one edition too many into an edition mark pda
    #[msg("You tried to insert one edition too many into an edition mark pda")]
    InvalidEditionIndex,

    // In the legacy system the reservation needs to be of size one for cpu limit reasons
    #[msg("In the legacy system the reservation needs to be of size one for cpu limit reasons")]
    ReservationArrayShouldBeSizeOne,

    /// Is Mutable can only be flipped to false
    #[msg("Is Mutable can only be flipped to false")]
    IsMutableCanOnlyBeFlippedToFalse,

    #[msg("Cannont Verify Collection in this Instruction")]
    CollectionCannotBeVerifiedInThisInstruction,

    #[msg("This instruction was deprecated in a previous release and is now removed")]
    Removed, //For the curious we cannot get rid of an instruction in the enum or move them or it will break our api, this is a friendly way to get rid of them

    #[msg("This token use method is burn and there are no remaining uses, it must be burned")]
    MustBeBurned,

    #[msg("This use method is invalid")]
    InvalidUseMethod,

    #[msg("Cannot Change Use Method after the first use")]
    CannotChangeUseMethodAfterFirstUse,

    #[msg("Cannot Change Remaining or Available uses after the first use")]
    CannotChangeUsesAfterFirstUse,

    // 80
    #[msg("Collection Not Found on Metadata")]
    CollectionNotFound,

    #[msg("Collection Update Authority is invalid")]
    InvalidCollectionUpdateAuthority,

    #[msg("Collection Must Be a Unique Master Edition v2")]
    CollectionMustBeAUniqueMasterEdition,

    #[msg("The Use Authority Record Already Exists, to modify it Revoke, then Approve")]
    UseAuthorityRecordAlreadyExists,

    #[msg("The Use Authority Record is empty or already revoked")]
    UseAuthorityRecordAlreadyRevoked,

    #[msg("This token has no uses")]
    Unusable,

    #[msg("There are not enough Uses left on this token.")]
    NotEnoughUses,

    #[msg("This Collection Authority Record Already Exists.")]
    CollectionAuthorityRecordAlreadyExists,

    #[msg("This Collection Authority Record Does Not Exist.")]
    CollectionAuthorityDoesNotExist,

    #[msg("This Use Authority Record is invalid.")]
    InvalidUseAuthorityRecord,

    // 90
    #[msg("This Collection Authority Record is invalid.")]
    InvalidCollectionAuthorityRecord,

    #[msg("Metadata does not match the freeze authority on the mint")]
    InvalidFreezeAuthority,

    #[msg("All tokens in this account have not been delegated to this user.")]
    InvalidDelegate,

    #[msg("Creator can not be adjusted once they are verified.")]
    CannotAdjustVerifiedCreator,

    #[msg("Verified creators cannot be removed.")]
    CannotRemoveVerifiedCreator,

    #[msg("Can not wipe verified creators.")]
    CannotWipeVerifiedCreators,

    #[msg("Not allowed to change seller fee basis points.")]
    NotAllowedToChangeSellerFeeBasisPoints,

    /// Edition override cannot be zero
    #[msg("Edition override cannot be zero")]
    EditionOverrideCannotBeZero,

    #[msg("Invalid User")]
    InvalidUser,

    /// Revoke Collection Authority signer is incorrect
    #[msg("Revoke Collection Authority signer is incorrect")]
    RevokeCollectionAuthoritySignerIncorrect,

    // 100
    #[msg("Token close failed")]
    TokenCloseFailed,

    /// 101 - Calling v1.3 function on unsized collection
    #[msg("Can't use this function on unsized collection")]
    UnsizedCollection,

    /// 102 - Calling v1.2 function on a sized collection
    #[msg("Can't use this function on a sized collection")]
    SizedCollection,

    /// 103 - Can't burn a verified member of a collection w/o providing collection metadata account
    #[msg(
        "Can't burn a verified member of a collection w/o providing collection metadata account"
    )]
    MissingCollectionMetadata,

    /// 104 - This NFT is not a member of the specified collection.
    #[msg("This NFT is not a member of the specified collection.")]
    NotAMemberOfCollection,

    /// 105 - This NFT is not a verified member of the specified collection.
    #[msg("This NFT is not a verified member of the specified collection.")]
    NotVerifiedMemberOfCollection,

    /// 106 - This NFT is not a collection parent NFT.
    #[msg("This NFT is not a collection parent NFT.")]
    NotACollectionParent,

    /// 107 - Could not determine a TokenStandard type.
    #[msg("Could not determine a TokenStandard type.")]
    CouldNotDetermineTokenStandard,

    /// 108 - Missing edition account for a non-fungible token type.
    #[msg("This mint account has an edition but none was provided.")]
    MissingEditionAccount,

    /// 109 - Not a Master Edition
    #[msg("This edition is not a Master Edition")]
    NotAMasterEdition,

    /// 110 - Master Edition has prints.
    #[msg("This Master Edition has existing prints")]
    MasterEditionHasPrints,

    /// 111 - Borsh Deserialization Error
    #[msg("Borsh Deserialization Error")]
    BorshDeserializationError,

    /// 112 - Cannot update a verified colleciton in this command
    #[msg("Cannot update a verified colleciton in this command")]
    CannotUpdateVerifiedCollection,

    /// 113 - Edition Account Doesnt Match Collection
    #[msg("Edition account aoesnt match collection ")]
    CollectionMasterEditionAccountInvalid,

    /// 114 - Item is already verified.
    #[msg("Item is already verified.")]
    AlreadyVerified,

    /// 115 - Item is already unverified.
    #[msg("Item is already unverified.")]
    AlreadyUnverified,
}
